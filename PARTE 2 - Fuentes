##author: "Mario A. Posadas"
---

## Librerías necesarias

```{r}
library(readxl)
library(dplyr)
library(janitor) 
library(DT)
library(stringi)
library(stringr)
library(arules)
library(tidyr)
library(purrr)
library(arulesViz)
library(ggplot2)
library(dplyr)
library(randomForest)
library(rpart)
library(rpart.plot)
library(genero)
library(arules)
```

## Repositorio

### Fuente 1 - Hechos delictivos INE

```{r}
ruta <- "D:/Desktop/Maestría Ciencias de la Computación/IV TRIMESTRE/Introducción a la minería de datos/Proyecto/Repositorio/FUENTE1-INE-HECHOS-DELICTIVOS/DELITOS-CONTRA-LIBERTAD-PNC"
archivos <- list.files(path = ruta, pattern = "\\.xlsx$", full.names = TRUE)

```

###### Renombramiento de columnas que tengan en común Año

```{r}
leer_con_prefijo <- function(archivo) {
  df <- read_excel(archivo, skip = 2)
  df <- clean_names(df)  # Limpia nombres 
  if (!"ano" %in% names(df)) {
    names(df)[1] <- "ano"
  }
  prefijo <- tools::file_path_sans_ext(basename(archivo))
  otras_cols <- setdiff(names(df), "ano")
  names(df)[names(df) != "ano"] <- paste0(prefijo, "_", otras_cols)
  return(df)
}

```

###### Lectura de todos los archivos

```{r}
lista_datos <- lapply(archivos, leer_con_prefijo)
```

###### Unión por año

```{r}
datos_fuente1 <- Reduce(function(x, y) full_join(x, y, by = "ano"), lista_datos)
```

###### Verificación de archivos cargados

```{r}
glimpse(datos_fuente1)
```
###### Vista resumida en tabla de la información cargada

```{r}
ver_tabla <- function(data, filas = 10) {
  if (!requireNamespace("DT", quietly = TRUE)) {
    install.packages("DT")
  }
  library(DT)
  
  datatable(
    data,
    options = list(pageLength = filas, scrollX = TRUE),
    rownames = FALSE
  )
}
ver_tabla(datos_fuente1)
```
### Fuente 2 - Médico Legal INACIF

```{r}
# Ruta del directorio FUENTE2
ruta_fuente2 <- "D:/Desktop/Maestría Ciencias de la Computación/IV TRIMESTRE/Introducción a la minería de datos/Proyecto/Repositorio/FUENTE2-MEDICO-LEGAL-INACIF"

# Listar todos los archivos Excel
archivos_fuente2 <- list.files(path = ruta_fuente2, pattern = "\\.xlsx$", full.names = TRUE)
```

###### Limpieza y orden de la información

```{r}
# Si existieran datos por limpiar:
leer_fuente2 <- function(archivo) {
  df <- read_excel(archivo)
  df <- clean_names(df)  # Limpia nombres: sin tildes, espacios, mayúsculas
  
  # Si el archivo tiene eva_ml y sexo_per_eva, renombrarlos para unificar:
  if ("eva_ml" %in% names(df)) {
    df <- df %>% rename(clasif_eval = eva_ml)
  }
  if ("sexo_per_eva" %in% names(df)) {
    df <- df %>% rename(sexo_per = sexo_per_eva)
  }
  
  # Agregar columna con nombre del archivo
  df <- df %>% mutate(fuente = basename(archivo))
  
  return(df)
}

# Leer y apilar todos los archivos
datos_fuente2 <- bind_rows(lapply(archivos_fuente2, leer_fuente2))
```

###### Verificar estructura

```{r}
glimpse(datos_fuente2)
```

### Fuente 3 - Médico Necropcia INACIF

```{r}
# Ruta del directorio FUENTE3
ruta_fuente3 <- "D:/Desktop/Maestría Ciencias de la Computación/IV TRIMESTRE/Introducción a la minería de datos/Proyecto/Repositorio/FUENTE3-MEDICO-NECROPCIA-INACIF"

# Listar todos los archivos Excel
archivos_fuente3 <- list.files(path = ruta_fuente3, pattern = "\\.xlsx$", full.names = TRUE)

# Extraer nombres de columna por archivo
nombres_df <- lapply(archivos_fuente3, function(archivo) {
  nombres <- names(read_excel(archivo, n_max = 0))
  data.frame(
    archivo = basename(archivo),
    columna = nombres,
    stringsAsFactors = FALSE
  )
}) %>% bind_rows()

# Mostrar como tabla
print(nombres_df)

# Función para normalizar nombres de columna
normalizar_nombres <- function(nombres) {
  nombres %>%
    stri_trans_general("Latin-ASCII") %>%       # Elimina tildes
    str_replace_all("ñ", "n") %>%               # Reemplaza ñ por n
    str_replace_all("[\\p{P}-[_]]+", "") %>%    # Elimina puntuación excepto _
    str_replace_all("\\s+", "_") %>%            # Reemplaza espacios por _
    tolower()                                   # Minúsculas
}

# Función para renombrar columnas específicas
unificar_nombres <- function(nombres) {
  reemplazos <- c(
    "causa_muerte" = "eva_mn",
    "ano_ing" = "ano_ocu",
    "mes_ing" = "mes_ocu",
    "dia_ing" = "dia_ocu",
    "dia_sem_ing" = "dia_sem_ocu",
    "sexo_per" = "sexo_per_eva"
  )
  ifelse(nombres %in% names(reemplazos), reemplazos[nombres], nombres)
}

```

  
  
###### Dentro de esta fuente se ha indentificado que en el año 2024 existe una columna 'g_edad_ninez_adolescencia', de la cual no se tienen registros de años anterior, por lo cual se excluye al no ser data significativa para comparación.

```{r}
# Función para leer y normalizar columnas, excluyendo g_edad_ninez_adolescencia
leer_fuente3 <- function(archivo) {
  df <- read_excel(archivo)
  
  nombres_originales <- names(df)
  nombres_normalizados <- normalizar_nombres(nombres_originales)
  
  # Asignar nombres normalizados temporalmente
  names(df) <- nombres_normalizados
  
  # Excluir columna ya normalizada
  if ("g_edad_ninez_adolescencia" %in% names(df)) {
    df <- df %>% select(-g_edad_ninez_adolescencia)
    nombres_normalizados <- names(df)  # Actualizar nombres tras exclusión
  }

  
  # Renombrar según mapeo
  nombres_unificados <- unificar_nombres(nombres_normalizados)
  
  # Verificar duplicados post-renombramiento
  if (any(duplicated(nombres_unificados))) {
    duplicados <- nombres_unificados[duplicated(nombres_unificados)]
    warning("Columnas duplicadas tras renombrar en ", basename(archivo), ": ",
            paste(duplicados, collapse = ", "))
    
    nombres_unificados <- make.unique(nombres_unificados, sep = "_dup")
  }
  
  names(df) <- nombres_unificados
  
  # Agregar columna de procedencia
  df <- df %>% mutate(fuente = basename(archivo))
  
  return(df)
}

# Leer todos los archivos
lista_fuente3 <- lapply(archivos_fuente3, leer_fuente3)

# Unificar columnas presentes en al menos uno de los archivos
todas_columnas <- unique(unlist(lapply(lista_fuente3, names)))

# Alinear columnas en todos los dataframes
alinear_columnas <- function(df, columnas_objetivo) {
  faltantes <- setdiff(columnas_objetivo, names(df))
  for (col in faltantes) {
    df[[col]] <- NA
  }
  df <- df[, columnas_objetivo]
  return(df)
}

# Aplicar alineación
datos_fuente3 <- bind_rows(lapply(lista_fuente3, function(df) alinear_columnas(df, todas_columnas)))

# Verificar estructura final
glimpse(datos_fuente3)
```
